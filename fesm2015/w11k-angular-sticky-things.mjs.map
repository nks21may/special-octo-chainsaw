{"version":3,"file":"w11k-angular-sticky-things.mjs","sources":["../../../../projects/angular-sticky-things/src/lib/sticky-thing.directive.ts","../../../../projects/angular-sticky-things/src/lib/angular-sticky-things.module.ts","../../../../projects/angular-sticky-things/src/index.ts","../../../../projects/angular-sticky-things/src/w11k-angular-sticky-things.ts"],"sourcesContent":["import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  HostListener,\n  Inject,\n  Input,\n  isDevMode,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID\n} from '@angular/core';\nimport {isPlatformBrowser} from '@angular/common';\nimport {BehaviorSubject, combineLatest, Observable, pipe, Subject, animationFrameScheduler} from 'rxjs';\nimport {auditTime, filter, map, share, startWith, takeUntil, throttleTime} from 'rxjs/operators';\n\n\nexport interface StickyPositions {\n  offsetY: number;\n  bottomBoundary: number | null;\n  upperScreenEdgeAt?: number;\n  marginTop?: number;\n  marginBottom?: number;\n}\n\nexport interface StickyStatus {\n  isSticky: boolean;\n  reachedUpperEdge: boolean;\n  reachedLowerEdge: boolean;\n  marginTop?: number;\n  marginBottom?: number;\n}\n\n@Directive({\n  selector: '[stickyThing]'\n})\nexport class StickyThingDirective implements OnInit, AfterViewInit, OnDestroy {\n\n  filterGate = false;\n  marginTop$ = new BehaviorSubject(0);\n  marginBottom$ = new BehaviorSubject(0);\n  enable$ = new BehaviorSubject(true);\n\n  @Input() scrollContainer: string | HTMLElement | undefined;\n  @Input() auditTime = 0;\n  @Input() set marginTop(value: number) {\n    this.marginTop$.next(value);\n  }\n\n  @Input() set marginBottom(value: number) {\n    this.marginBottom$.next(value);\n  }\n\n  @Input() set enable(value: boolean) {\n    this.enable$.next(value);\n  }\n  @Input('spacer') spacerElement: HTMLElement | undefined;\n  @Input('boundary') boundaryElement: HTMLElement | undefined;\n  sticky = false;\n  @HostBinding('class.is-sticky') isSticky = false;\n  @HostBinding('class.boundary-reached') boundaryReached = false;\n  @HostBinding('class.upper-bound-reached') upperBoundReached = false;\n  @Output() stickyStatus: EventEmitter<StickyStatus> = new EventEmitter<StickyStatus>();\n  @Output() stickyPosition: EventEmitter<StickyPositions> = new EventEmitter<StickyPositions>();\n\n  /**\n   * The field represents some position values in normal (not sticky) mode.\n   * If the browser size or the content of the page changes, this value must be recalculated.\n   * */\n  private scroll$ = new Subject<number>();\n  private scrollThrottled$: Observable<number>;\n  private target = this.getScrollTarget();\n\n  private resize$ = new Subject<void>();\n  private resizeThrottled$: Observable<void>;\n  private extraordinaryChange$ = new BehaviorSubject<void>(undefined);\n\n  private status$: Observable<StickyStatus>;\n\n  private componentDestroyed = new Subject<void>();\n\n  constructor(private stickyElement: ElementRef, @Inject(PLATFORM_ID) private platformId: string) {\n\n    /**\n     * Throttle the scroll to animation frame (around 16.67ms) */\n    this.scrollThrottled$ = this.scroll$\n      .pipe(\n        throttleTime(0, animationFrameScheduler),\n        share()\n      );\n\n    /**\n     * Throttle the resize to animation frame (around 16.67ms) */\n    this.resizeThrottled$ = this.resize$\n      .pipe(\n        throttleTime(0, animationFrameScheduler),\n        // emit once since we are currently using combineLatest\n        startWith(null),\n        share()\n      );\n\n\n    this.status$ = combineLatest(\n      this.enable$,\n      this.scrollThrottled$,\n      this.marginTop$,\n      this.marginBottom$,\n      this.extraordinaryChange$,\n      this.resizeThrottled$,\n    )\n      .pipe(\n        filter(([enabled]) => this.checkEnabled(enabled)),\n        map(([enabled, pageYOffset, marginTop, marginBottom]) => this.determineStatus(this.determineElementOffsets(), pageYOffset, marginTop, marginBottom, enabled)),\n        share(),\n      );\n\n  }\n\n  ngAfterViewInit(): void {\n    const operators = this.scrollContainer ?\n      pipe(takeUntil(this.componentDestroyed)) :\n      pipe(auditTime(this.auditTime), takeUntil(this.componentDestroyed));\n    this.status$\n      .pipe(operators)\n      .subscribe((status: StickyStatus) => {\n        this.setSticky(status);\n        this.setStatus(status);\n      });\n  }\n\n  public recalculate(): void {\n    if (isPlatformBrowser(this.platformId)) {\n      // Make sure to be in the next tick by using timeout\n      setTimeout(() => {\n        this.extraordinaryChange$.next(undefined);\n      }, 0);\n    }\n  }\n\n\n  /**\n   * This is nasty code that should be refactored at some point.\n   *\n   * The Problem is, we filter for enabled. So that the code doesn't run\n   * if @Input enabled = false. But if the user disables, we need exactly 1\n   * emit in order to reset and call removeSticky. So this method basically\n   * turns the filter in \"filter, but let the first pass\".\n   * */\n  checkEnabled(enabled: boolean): boolean {\n\n    if (!isPlatformBrowser(this.platformId)) {\n      return false;\n    }\n\n    if (enabled) {\n      // reset the gate\n      this.filterGate = false;\n      return true;\n    } else {\n      if (this.filterGate) {\n        // gate closed, first emit has happened\n        return false;\n      } else {\n        // this is the first emit for enabled = false,\n        // let it pass, and activate the gate\n        // so the next wont pass.\n        this.filterGate = true;\n        return true;\n      }\n    }\n\n\n  }\n\n  @HostListener('window:resize', [])\n  onWindowResize(): void {\n    if (isPlatformBrowser(this.platformId)) {\n      this.resize$.next();\n    }\n  }\n\n  setupListener(): void {\n    if (isPlatformBrowser(this.platformId)) {\n      const target = this.getScrollTarget();\n      target.addEventListener('scroll', this.listener);\n    }\n  }\n\n  listener = (e: Event) => {\n    const upperScreenEdgeAt = (e.target as HTMLElement).scrollTop || window.pageYOffset;\n    this.scroll$.next(upperScreenEdgeAt);\n  }\n\n\n  ngOnInit(): void {\n    this.checkSetup();\n    this.setupListener();\n  }\n\n  ngOnDestroy(): void {\n    this.target.removeEventListener('scroll', this.listener);\n    this.componentDestroyed.next();\n  }\n\n  private getScrollTarget(): Element | Window {\n    let target: Element | Window;\n    if (this.scrollContainer && typeof this.scrollContainer === 'string') {\n      target = document.querySelector(this.scrollContainer);\n      this.marginTop$.next(Infinity);\n      this.auditTime = 0;\n    } else if (this.scrollContainer && this.scrollContainer instanceof HTMLElement) {\n      target = this.scrollContainer;\n      this.marginTop$.next(Infinity);\n      this.auditTime = 0;\n    } else {\n      target = window;\n    }\n    return target;\n  }\n  getComputedStyle(el: HTMLElement): ClientRect | DOMRect {\n    return el.getBoundingClientRect();\n  }\n\n  private determineStatus(originalVals: StickyPositions, pageYOffset: number, marginTop: number, marginBottom: number, enabled: boolean) {\n    const elementPos = this.determineElementOffsets();\n    let isSticky = enabled && pageYOffset > originalVals.offsetY;\n    if (pageYOffset < elementPos.offsetY) {\n      isSticky = false;\n    }\n    const stickyElementHeight = this.getComputedStyle(this.stickyElement.nativeElement).height;\n    const reachedLowerEdge = (this.boundaryElement != null) ? this.boundaryElement && window.pageYOffset + stickyElementHeight + marginBottom >= (originalVals.bottomBoundary - marginTop * 1.0) : undefined;\n    const reachedUpperEdge = (this.boundaryElement != null) ? window.pageYOffset < (this.boundaryElement.offsetTop + marginTop * 1.0) : undefined;\n    this.stickyPosition.emit({...elementPos, upperScreenEdgeAt: pageYOffset, marginBottom, marginTop});\n    return {\n      isSticky,\n      reachedUpperEdge,\n      reachedLowerEdge,\n    };\n\n  }\n\n\n  // not always pixel. e.g. ie9\n  private getMargins(): { top: number, bottom: number } {\n    const stickyStyles = window.getComputedStyle(this.stickyElement.nativeElement);\n    const top = parseInt(stickyStyles.marginTop, 10);\n    const bottom = parseInt(stickyStyles.marginBottom, 10);\n    return {top, bottom};\n  }\n\n  /**\n   * Gets the offset for element. If the element\n   * currently is sticky, it will get removed\n   * to access the original position. Other\n   * wise this would just be 0 for fixed elements. */\n  private determineElementOffsets(): StickyPositions {\n    if (this.sticky) {\n      this.removeSticky();\n    }\n    let bottomBoundary: number | null = null;\n\n    if (this.boundaryElement) {\n      const boundaryElementHeight = this.getComputedStyle(this.boundaryElement).height;\n      const boundaryElementOffset = getPosition(this.boundaryElement).y;\n      bottomBoundary = boundaryElementHeight + boundaryElementOffset;\n    }\n    return {\n      offsetY: (getPosition(this.stickyElement.nativeElement).y - this.marginTop$.value), bottomBoundary\n    };\n  }\n\n  private makeSticky(boundaryReached: boolean = false, marginTop: number, marginBottom: number): void {\n    // do this before setting it to pos:fixed\n    const {width, height, left} = this.getComputedStyle(this.stickyElement.nativeElement);\n    const offSet = boundaryReached ? (this.getComputedStyle(this.boundaryElement).bottom - height - this.marginBottom$.value) : this.marginTop$.value;\n    if (this.scrollContainer && !this.sticky) {\n      this.stickyElement.nativeElement.style.position = 'sticky';\n      this.stickyElement.nativeElement.style.top = '0px';\n      this.sticky = true;\n    } else {\n      this.stickyElement.nativeElement.style.position = 'fixed';\n      this.stickyElement.nativeElement.style.top = offSet + 'px';\n      this.stickyElement.nativeElement.style.left = left + 'px';\n      this.stickyElement.nativeElement.style.width = `${width}px`;\n    }\n    if (this.spacerElement) {\n      const spacerHeight = marginBottom + height + marginTop;\n      this.spacerElement.style.height = `${spacerHeight}px`;\n    }\n  }\n\n  private determineBoundaryReached(boundaryHeight: number, stickyElHeight: number, cssMargins, marginTop: number, marginBottom: number, upperScreenEdgeAt: number) {\n\n    const boundaryElementPos = getPosition(this.boundaryElement);\n\n    const boundaryElementLowerEdge = boundaryElementPos.y + boundaryHeight;\n    const lowerEdgeStickyElement = upperScreenEdgeAt + stickyElHeight + marginTop + cssMargins.top + marginBottom + cssMargins.bottom;\n\n    return boundaryElementLowerEdge <= lowerEdgeStickyElement;\n  }\n\n  private checkSetup() {\n    if (isDevMode() && !this.spacerElement) {\n      console.warn(`******There might be an issue with your sticky directive!******\n\nYou haven't specified a spacer element. This will cause the page to jump.\n\nBest practise is to provide a spacer element (e.g. a div) right before/after the sticky element.\nThen pass the spacer element as input:\n\n<div #spacer></div>\n\n<div stickyThing=\"\" [spacer]=\"spacer\">\n    I am sticky!\n</div>`);\n    }\n  }\n\n\n  private setSticky(status: StickyStatus): void {\n    if (status.isSticky) {\n      if (this.upperBoundReached) {\n        this.removeSticky();\n        this.isSticky = false;\n      } else {\n        this.makeSticky(status.reachedLowerEdge, status.marginTop, status.marginBottom);\n        this.isSticky = true;\n      }\n    } else {\n      this.removeSticky();\n    }\n  }\n\n  private setStatus(status: StickyStatus) {\n    this.upperBoundReached = status.reachedUpperEdge;\n    this.boundaryReached = status.reachedLowerEdge;\n    this.stickyStatus.next(status);\n  }\n\n  private removeSticky(): void {\n    this.boundaryReached = false;\n    this.sticky = false;\n    this.stickyElement.nativeElement.style.position = '';\n    this.stickyElement.nativeElement.style.width = 'auto';\n    this.stickyElement.nativeElement.style.left = 'auto';\n    this.stickyElement.nativeElement.style.top = 'auto';\n    if (this.spacerElement) {\n      this.spacerElement.style.height = '0';\n    }\n  }\n}\n\n// Thanks to https://stanko.github.io/javascript-get-element-offset/\nfunction getPosition(el) {\n  let top = 0;\n  let left = 0;\n  let element = el;\n\n  // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent;\n  } while (element);\n\n  return {\n    y: top,\n    x: left,\n  };\n}\n","import {NgModule} from '@angular/core';\nimport {StickyThingDirective} from './sticky-thing.directive';\n\n@NgModule({\n  imports: [],\n  declarations: [\n    StickyThingDirective,\n  ],\n  exports: [\n    StickyThingDirective,\n  ]\n})\nexport class AngularStickyThingsModule {\n}\n","/*\n * Public API Surface of angular-sticky-things\n */\n\nexport * from './lib/sticky-thing.directive';\nexport * from './lib/angular-sticky-things.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;MAuCa,oBAAoB,CAAA;IAS/B,IAAa,SAAS,CAAC,KAAa,EAAA;AAClC,QAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC7B;IAED,IAAa,YAAY,CAAC,KAAa,EAAA;AACrC,QAAA,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAChC;IAED,IAAa,MAAM,CAAC,KAAc,EAAA;AAChC,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC1B;IA0BD,WAAoB,CAAA,aAAyB,EAA+B,UAAkB,EAAA;AAA1E,QAAA,IAAa,CAAA,aAAA,GAAb,aAAa,CAAY;AAA+B,QAAA,IAAU,CAAA,UAAA,GAAV,UAAU,CAAQ;AA3C9F,QAAA,IAAU,CAAA,UAAA,GAAG,KAAK,CAAC;QACnB,IAAA,CAAA,UAAU,GAAG,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC;QACpC,IAAA,CAAA,aAAa,GAAG,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC;QACvC,IAAA,CAAA,OAAO,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,CAAC;AAG3B,QAAA,IAAS,CAAA,SAAA,GAAG,CAAC,CAAC;AAcvB,QAAA,IAAM,CAAA,MAAA,GAAG,KAAK,CAAC;AACiB,QAAA,IAAQ,CAAA,QAAA,GAAG,KAAK,CAAC;AACV,QAAA,IAAe,CAAA,eAAA,GAAG,KAAK,CAAC;AACrB,QAAA,IAAiB,CAAA,iBAAA,GAAG,KAAK,CAAC;AAC1D,QAAA,IAAA,CAAA,YAAY,GAA+B,IAAI,YAAY,EAAgB,CAAC;AAC5E,QAAA,IAAA,CAAA,cAAc,GAAkC,IAAI,YAAY,EAAmB,CAAC;AAE9F;;;AAGK;AACG,QAAA,IAAA,CAAA,OAAO,GAAG,IAAI,OAAO,EAAU,CAAC;AAEhC,QAAA,IAAA,CAAA,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;AAEhC,QAAA,IAAA,CAAA,OAAO,GAAG,IAAI,OAAO,EAAQ,CAAC;QAE9B,IAAA,CAAA,oBAAoB,GAAG,IAAI,eAAe,CAAO,SAAS,CAAC,CAAC;AAI5D,QAAA,IAAA,CAAA,kBAAkB,GAAG,IAAI,OAAO,EAAQ,CAAC;AA6GjD,QAAA,IAAA,CAAA,QAAQ,GAAG,CAAC,CAAQ,KAAI;YACtB,MAAM,iBAAiB,GAAI,CAAC,CAAC,MAAsB,CAAC,SAAS,IAAI,MAAM,CAAC,WAAW,CAAC;AACpF,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;AACvC,SAAC,CAAA;AA5GC;AAC6D;AAC7D,QAAA,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO;aACjC,IAAI,CACH,YAAY,CAAC,CAAC,EAAE,uBAAuB,CAAC,EACxC,KAAK,EAAE,CACR,CAAC;AAEJ;AAC6D;AAC7D,QAAA,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO;AACjC,aAAA,IAAI,CACH,YAAY,CAAC,CAAC,EAAE,uBAAuB,CAAC;;AAExC,QAAA,SAAS,CAAC,IAAI,CAAC,EACf,KAAK,EAAE,CACR,CAAC;AAGJ,QAAA,IAAI,CAAC,OAAO,GAAG,aAAa,CAC1B,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,oBAAoB,EACzB,IAAI,CAAC,gBAAgB,CACtB;aACE,IAAI,CACH,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,EACjD,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,YAAY,CAAC,KAAK,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,uBAAuB,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,EAC7J,KAAK,EAAE,CACR,CAAC;KAEL;IAED,eAAe,GAAA;AACb,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe;YACpC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AACxC,YAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC;AACtE,QAAA,IAAI,CAAC,OAAO;aACT,IAAI,CAAC,SAAS,CAAC;AACf,aAAA,SAAS,CAAC,CAAC,MAAoB,KAAI;AAClC,YAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACvB,YAAA,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACzB,SAAC,CAAC,CAAC;KACN;IAEM,WAAW,GAAA;AAChB,QAAA,IAAI,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;;YAEtC,UAAU,CAAC,MAAK;AACd,gBAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aAC3C,EAAE,CAAC,CAAC,CAAC;AACP,SAAA;KACF;AAGD;;;;;;;AAOK;AACL,IAAA,YAAY,CAAC,OAAgB,EAAA;AAE3B,QAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;AACvC,YAAA,OAAO,KAAK,CAAC;AACd,SAAA;AAED,QAAA,IAAI,OAAO,EAAE;;AAEX,YAAA,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;AACxB,YAAA,OAAO,IAAI,CAAC;AACb,SAAA;AAAM,aAAA;YACL,IAAI,IAAI,CAAC,UAAU,EAAE;;AAEnB,gBAAA,OAAO,KAAK,CAAC;AACd,aAAA;AAAM,iBAAA;;;;AAIL,gBAAA,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;AACvB,gBAAA,OAAO,IAAI,CAAC;AACb,aAAA;AACF,SAAA;KAGF;IAGD,cAAc,GAAA;AACZ,QAAA,IAAI,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;AACtC,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;AACrB,SAAA;KACF;IAED,aAAa,GAAA;AACX,QAAA,IAAI,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;AACtC,YAAA,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;YACtC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AAClD,SAAA;KACF;IAQD,QAAQ,GAAA;QACN,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,aAAa,EAAE,CAAC;KACtB;IAED,WAAW,GAAA;QACT,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AACzD,QAAA,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC;KAChC;IAEO,eAAe,GAAA;AACrB,QAAA,IAAI,MAAwB,CAAC;QAC7B,IAAI,IAAI,CAAC,eAAe,IAAI,OAAO,IAAI,CAAC,eAAe,KAAK,QAAQ,EAAE;YACpE,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AACtD,YAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/B,YAAA,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACpB,SAAA;aAAM,IAAI,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,eAAe,YAAY,WAAW,EAAE;AAC9E,YAAA,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;AAC9B,YAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/B,YAAA,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACpB,SAAA;AAAM,aAAA;YACL,MAAM,GAAG,MAAM,CAAC;AACjB,SAAA;AACD,QAAA,OAAO,MAAM,CAAC;KACf;AACD,IAAA,gBAAgB,CAAC,EAAe,EAAA;AAC9B,QAAA,OAAO,EAAE,CAAC,qBAAqB,EAAE,CAAC;KACnC;IAEO,eAAe,CAAC,YAA6B,EAAE,WAAmB,EAAE,SAAiB,EAAE,YAAoB,EAAE,OAAgB,EAAA;AACnI,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAClD,IAAI,QAAQ,GAAG,OAAO,IAAI,WAAW,GAAG,YAAY,CAAC,OAAO,CAAC;AAC7D,QAAA,IAAI,WAAW,GAAG,UAAU,CAAC,OAAO,EAAE;YACpC,QAAQ,GAAG,KAAK,CAAC;AAClB,SAAA;AACD,QAAA,MAAM,mBAAmB,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC;AAC3F,QAAA,MAAM,gBAAgB,GAAG,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,IAAI,IAAI,CAAC,eAAe,IAAI,MAAM,CAAC,WAAW,GAAG,mBAAmB,GAAG,YAAY,KAAK,YAAY,CAAC,cAAc,GAAG,SAAS,GAAG,GAAG,CAAC,GAAG,SAAS,CAAC;AACzM,QAAA,MAAM,gBAAgB,GAAG,CAAC,IAAI,CAAC,eAAe,IAAI,IAAI,IAAI,MAAM,CAAC,WAAW,IAAI,IAAI,CAAC,eAAe,CAAC,SAAS,GAAG,SAAS,GAAG,GAAG,CAAC,GAAG,SAAS,CAAC;AAC9I,QAAA,IAAI,CAAC,cAAc,CAAC,IAAI,iCAAK,UAAU,CAAA,EAAA,EAAE,iBAAiB,EAAE,WAAW,EAAE,YAAY,EAAE,SAAS,IAAE,CAAC;QACnG,OAAO;YACL,QAAQ;YACR,gBAAgB;YAChB,gBAAgB;SACjB,CAAC;KAEH;;IAIO,UAAU,GAAA;AAChB,QAAA,MAAM,YAAY,GAAG,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QAC/E,MAAM,GAAG,GAAG,QAAQ,CAAC,YAAY,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;QACjD,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AACvD,QAAA,OAAO,EAAC,GAAG,EAAE,MAAM,EAAC,CAAC;KACtB;AAED;;;;AAImD;IAC3C,uBAAuB,GAAA;QAC7B,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,CAAC,YAAY,EAAE,CAAC;AACrB,SAAA;QACD,IAAI,cAAc,GAAkB,IAAI,CAAC;QAEzC,IAAI,IAAI,CAAC,eAAe,EAAE;AACxB,YAAA,MAAM,qBAAqB,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,CAAC;YACjF,MAAM,qBAAqB,GAAG,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAClE,YAAA,cAAc,GAAG,qBAAqB,GAAG,qBAAqB,CAAC;AAChE,SAAA;QACD,OAAO;YACL,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,cAAc;SACnG,CAAC;KACH;AAEO,IAAA,UAAU,CAAC,eAA2B,GAAA,KAAK,EAAE,SAAiB,EAAE,YAAoB,EAAA;;AAE1F,QAAA,MAAM,EAAC,KAAK,EAAE,MAAM,EAAE,IAAI,EAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;AACtF,QAAA,MAAM,MAAM,GAAG,eAAe,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC;QAClJ,IAAI,IAAI,CAAC,eAAe,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACxC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;YAC3D,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC;AACnD,YAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACpB,SAAA;AAAM,aAAA;YACL,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,QAAQ,GAAG,OAAO,CAAC;AAC1D,YAAA,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,MAAM,GAAG,IAAI,CAAC;AAC3D,YAAA,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;AAC1D,YAAA,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,GAAG,CAAA,EAAG,KAAK,CAAA,EAAA,CAAI,CAAC;AAC7D,SAAA;QACD,IAAI,IAAI,CAAC,aAAa,EAAE;AACtB,YAAA,MAAM,YAAY,GAAG,YAAY,GAAG,MAAM,GAAG,SAAS,CAAC;YACvD,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,GAAG,CAAA,EAAG,YAAY,CAAA,EAAA,CAAI,CAAC;AACvD,SAAA;KACF;IAEO,wBAAwB,CAAC,cAAsB,EAAE,cAAsB,EAAE,UAAU,EAAE,SAAiB,EAAE,YAAoB,EAAE,iBAAyB,EAAA;QAE7J,MAAM,kBAAkB,GAAG,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAE7D,QAAA,MAAM,wBAAwB,GAAG,kBAAkB,CAAC,CAAC,GAAG,cAAc,CAAC;AACvE,QAAA,MAAM,sBAAsB,GAAG,iBAAiB,GAAG,cAAc,GAAG,SAAS,GAAG,UAAU,CAAC,GAAG,GAAG,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC;QAElI,OAAO,wBAAwB,IAAI,sBAAsB,CAAC;KAC3D;IAEO,UAAU,GAAA;AAChB,QAAA,IAAI,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACtC,OAAO,CAAC,IAAI,CAAC,CAAA;;;;;;;;;;;AAWZ,MAAA,CAAA,CAAC,CAAC;AACJ,SAAA;KACF;AAGO,IAAA,SAAS,CAAC,MAAoB,EAAA;QACpC,IAAI,MAAM,CAAC,QAAQ,EAAE;YACnB,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBAC1B,IAAI,CAAC,YAAY,EAAE,CAAC;AACpB,gBAAA,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AACvB,aAAA;AAAM,iBAAA;AACL,gBAAA,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,YAAY,CAAC,CAAC;AAChF,gBAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AACtB,aAAA;AACF,SAAA;AAAM,aAAA;YACL,IAAI,CAAC,YAAY,EAAE,CAAC;AACrB,SAAA;KACF;AAEO,IAAA,SAAS,CAAC,MAAoB,EAAA;AACpC,QAAA,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,gBAAgB,CAAC;AACjD,QAAA,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,gBAAgB,CAAC;AAC/C,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAChC;IAEO,YAAY,GAAA;AAClB,QAAA,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;AAC7B,QAAA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,QAAQ,GAAG,EAAE,CAAC;QACrD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC;QACtD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,GAAG,MAAM,CAAC;QACrD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC;QACpD,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC;AACvC,SAAA;KACF;;AAzTU,oBAAA,CAAA,IAAA,GAAA,SAAA,4BAAA,CAAA,CAAA,EAAA,EAAA,OAAA,KAAA,CAAA,IAAA,oBAAoB,4DA6CwB,WAAW,CAAA,CAAA,CAAA,EAAA,CAAA;uEA7CvD,oBAAoB,EAAA,SAAA,EAAA,CAAA,CAAA,EAAA,EAAA,aAAA,EAAA,EAAA,CAAA,CAAA,EAAA,QAAA,EAAA,CAAA,EAAA,YAAA,EAAA,SAAA,iCAAA,CAAA,EAAA,EAAA,GAAA,EAAA;QAAA,IAAA,EAAA,GAAA,CAAA,EAAA;uGAApB,GAAgB,CAAA,cAAA,EAAA,CAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,eAAA,CAAA,CAAA;;;;;;;4EAAhB,oBAAoB,EAAA,CAAA;kBAHhC,SAAS;AAAC,YAAA,IAAA,EAAA,CAAA;AACT,oBAAA,QAAQ,EAAE,eAAe;iBAC1B,CAAA;;;8BA8CiD,MAAM;+BAAC,WAAW,CAAA;;SAtCzD,eAAe,EAAA,CAAA;sBAAvB,KAAK;gBACG,SAAS,EAAA,CAAA;sBAAjB,KAAK;gBACO,SAAS,EAAA,CAAA;sBAArB,KAAK;gBAIO,YAAY,EAAA,CAAA;sBAAxB,KAAK;gBAIO,MAAM,EAAA,CAAA;sBAAlB,KAAK;gBAGW,aAAa,EAAA,CAAA;sBAA7B,KAAK;uBAAC,QAAQ,CAAA;gBACI,eAAe,EAAA,CAAA;sBAAjC,KAAK;uBAAC,UAAU,CAAA;gBAEe,QAAQ,EAAA,CAAA;sBAAvC,WAAW;uBAAC,iBAAiB,CAAA;gBACS,eAAe,EAAA,CAAA;sBAArD,WAAW;uBAAC,wBAAwB,CAAA;gBACK,iBAAiB,EAAA,CAAA;sBAA1D,WAAW;uBAAC,2BAA2B,CAAA;gBAC9B,YAAY,EAAA,CAAA;sBAArB,MAAM;gBACG,cAAc,EAAA,CAAA;sBAAvB,MAAM;gBAgHP,cAAc,EAAA,CAAA;sBADb,YAAY;AAAC,gBAAA,IAAA,EAAA,CAAA,eAAe,EAAE,EAAE,CAAA;;;AAkLnC;AACA,SAAS,WAAW,CAAC,EAAE,EAAA;IACrB,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,IAAI,OAAO,GAAG,EAAE,CAAC;;;IAIjB,GAAG;AACD,QAAA,GAAG,IAAI,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;AAC9B,QAAA,IAAI,IAAI,OAAO,CAAC,UAAU,IAAI,CAAC,CAAC;AAChC,QAAA,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC;AAChC,KAAA,QAAQ,OAAO,EAAE;IAElB,OAAO;AACL,QAAA,CAAC,EAAE,GAAG;AACN,QAAA,CAAC,EAAE,IAAI;KACR,CAAC;AACJ;;MCzWa,yBAAyB,CAAA;;kGAAzB,yBAAyB,GAAA,CAAA,EAAA,CAAA;2EAAzB,yBAAyB,EAAA,CAAA,CAAA;;;4EAAzB,yBAAyB,EAAA,CAAA;kBATrC,QAAQ;AAAC,YAAA,IAAA,EAAA,CAAA;AACR,oBAAA,OAAO,EAAE,EAAE;AACX,oBAAA,YAAY,EAAE;wBACZ,oBAAoB;AACrB,qBAAA;AACD,oBAAA,OAAO,EAAE;wBACP,oBAAoB;AACrB,qBAAA;iBACF,CAAA;;;wFACY,yBAAyB,EAAA,EAAA,YAAA,EAAA,CANlC,oBAAoB,CAAA,EAAA,OAAA,EAAA,CAGpB,oBAAoB,CAAA,EAAA,CAAA,CAAA,EAAA,GAAA;;ACTxB;;AAEG;;ACFH;;AAEG;;;;"}